<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modeling for Polaroidize-it</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      background: #f5f5f0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Space Mono', monospace;
      padding: 20px;
      color: #1a1a1a;
    }

    .container {
      max-width: 600px;
      width: 100%;
      background: #fff;
      border: 3px solid #1a1a1a;
      padding: 40px 30px;
      box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.1);
    }

    h1 {
      text-align: center;
      margin-bottom: 10px;
      font-size: 20px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 3px;
    }

    .step-indicator {
      text-align: center;
      font-size: 11px;
      color: #666;
      margin-bottom: 30px;
      letter-spacing: 1px;
    }

    .reassurance {
      background: #f9f9f9;
      border: 2px dashed #ccc;
      padding: 15px;
      margin-top: 15px;
      font-size: 11px;
      line-height: 1.6;
      color: #666;
      display: none;
    }

    .reassurance.visible {
      display: block;
    }

    .reassurance strong {
      display: block;
      margin-bottom: 8px;
      font-size: 11px;
      color: #1a1a1a;
    }

    .video-container {
      position: relative;
      width: 100%;
      margin: 0 auto 25px;
      overflow: hidden;
      background: #1a1a1a;
      border: 3px solid #1a1a1a;
      background-image:
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 19px,
          rgba(255, 255, 255, 0.1) 19px,
          rgba(255, 255, 255, 0.1) 20px
        ),
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 19px,
          rgba(255, 255, 255, 0.1) 19px,
          rgba(255, 255, 255, 0.1) 20px
        );
    }

    #video {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0;
      pointer-events: none;
      z-index: -1;
    }

    #mosaicCanvas {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      transform: scaleX(-1);
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
      filter: grayscale(100%) contrast(1.1);
    }

    .live-badge {
      position: absolute;
      top: 12px;
      right: 12px;
      background: #1a1a1a;
      color: #fff;
      padding: 6px 12px;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 2px;
      display: none;
    }

    .live-badge.active {
      display: block;
    }

    .cta-section {
      text-align: center;
    }

    button {
      width: 100%;
      padding: 16px 32px;
      border: 3px solid #1a1a1a;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-family: 'Space Mono', monospace;
      background: #fff;
      color: #1a1a1a;
      margin-bottom: 0;
    }

    button:hover:not(:disabled) {
      background: #1a1a1a;
      color: #fff;
    }

    button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      background: #f0f0f0;
      color: #999;
    }

    /* Prominent start button */
    #startBtn {
      background: #1a1a1a;
      color: #fff;
      padding: 20px 32px;
      font-size: 14px;
      letter-spacing: 3px;
      box-shadow: 0 4px 0 #000;
    }

    #startBtn:hover {
      background: #000;
      transform: translateY(-2px);
      box-shadow: 0 6px 0 #000;
    }

    #startBtn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 #000;
    }

    /* Subtle end button */
    #stopBtn {
      background: transparent;
      border: 2px solid #ccc;
      color: #999;
      font-size: 10px;
      padding: 10px 20px;
      margin-top: 15px;
      letter-spacing: 1px;
    }

    #stopBtn:hover {
      background: #f5f5f5;
      border-color: #999;
      color: #666;
    }

    .final-step-label {
      text-align: center;
      font-size: 11px;
      color: #10b981;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-bottom: 12px;
      display: none;
    }

    .final-step-label.visible {
      display: block;
    }

    .settings {
      display: none;
      margin-bottom: 20px;
      padding: 20px;
      background: #f9f9f9;
      border: 2px solid #ddd;
    }

    .settings.visible {
      display: block;
    }

    .setting-row {
      margin-bottom: 15px;
    }

    .setting-row label {
      display: block;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 5px;
      color: #666;
    }

    .setting-row input,
    .setting-row select {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      background: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 11px;
    }

    .status {
      text-align: center;
      font-size: 10px;
      color: #666;
      margin-top: 15px;
      letter-spacing: 1px;
    }

    .status.success {
      color: #10b981;
    }

    /* Polaroid gallery */
    .polaroid-gallery {
      margin-top: 30px;
      padding-top: 30px;
      border-top: 2px solid #ddd;
      display: none;
    }

    .polaroid-gallery.visible {
      display: block;
    }

    .polaroid-gallery-header {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 20px;
      text-align: center;
      color: #1a1a1a;
    }

    .polaroid-item {
      background: #fff;
      border: 3px solid #1a1a1a;
      padding: 15px;
      box-shadow: 10px 10px 0 rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
      animation: polaroidDrop 0.5s ease-out;
    }

    @keyframes polaroidDrop {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .polaroid-item img {
      width: 100%;
      display: block;
      margin-bottom: 15px;
    }

    .polaroid-item-actions {
      display: flex;
      gap: 8px;
    }

    .polaroid-item-btn {
      flex: 1;
      padding: 10px;
      border: 2px solid #1a1a1a;
      background: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.15s ease;
    }

    .polaroid-item-btn:hover {
      background: #1a1a1a;
      color: #fff;
    }

    .polaroid-item-btn.download {
      background: #1a1a1a;
      color: #fff;
    }

    .polaroid-item-btn.download:hover {
      background: #000;
    }

    /* Toast notification */
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #1a1a1a;
      color: #fff;
      padding: 15px 20px;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      font-family: 'Space Mono', monospace;
      font-size: 11px;
      letter-spacing: 0.5px;
      z-index: 2000;
      display: none;
      flex-direction: column;
      gap: 10px;
      max-width: 280px;
      animation: toastSlideIn 0.3s ease-out;
    }

    .toast.show {
      display: flex;
    }

    @keyframes toastSlideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .toast-message {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toast-actions {
      display: flex;
      gap: 8px;
    }

    .toast-btn {
      padding: 6px 12px;
      border: 2px solid #fff;
      background: transparent;
      color: #fff;
      font-family: 'Space Mono', monospace;
      font-size: 10px;
      font-weight: 700;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      transition: all 0.15s ease;
    }

    .toast-btn:hover {
      background: #fff;
      color: #1a1a1a;
    }

    .toast-btn.primary {
      background: #fff;
      color: #1a1a1a;
    }

    .toast-btn.primary:hover {
      background: #f0f0f0;
    }

    @media (max-width: 640px) {
      .toast {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
      }
    }

    @media (max-width: 640px) {
      .container {
        padding: 30px 20px;
      }

      h1 {
        font-size: 16px;
      }

      button {
        font-size: 11px;
      }

    }

    /* Flash effect for when photographer takes photo */
    .screen-flash {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 9999;
      opacity: 0;
    }

    .screen-flash.active {
      animation: camera-flash 0.6s ease-out;
    }

    @keyframes camera-flash {
      0% {
        opacity: 0;
        background: radial-gradient(ellipse 150% 150% at 50% 50%, #fffef0 0%, #fffbe8 20%, rgba(255,250,230,0.8) 40%, transparent 70%);
      }
      15% {
        opacity: 1;
        background: radial-gradient(ellipse 180% 180% at 50% 50%, #ffffff 0%, #fffef5 25%, rgba(255,252,240,0.9) 50%, rgba(255,248,220,0.4) 80%, transparent 100%);
      }
      30% {
        opacity: 0.8;
        background: radial-gradient(ellipse 200% 200% at 50% 50%, #fffef0 0%, #ffeaa7 30%, rgba(255,234,167,0.5) 60%, transparent 90%);
      }
      100% {
        opacity: 0;
        background: radial-gradient(ellipse 250% 250% at 50% 50%, #ffeaa7 0%, transparent 50%);
      }
    }
  </style>
</head>
<body>
  <!-- Flash Effect -->
  <div class="screen-flash" id="screenFlash"></div>

  <!-- Toast Notification -->
  <div class="toast" id="toast">
    <div class="toast-message" id="toastMessage"></div>
    <div class="toast-actions" id="toastActions"></div>
  </div>

  <div class="container">
    <h1>Modeling for Polaroidize-it</h1>
    <div class="step-indicator" id="stepIndicator">Step 1 of 2</div>

    <div class="video-container">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="mosaicCanvas"></canvas>
      <div class="live-badge" id="liveBadge">LIVE</div>
    </div>

    <div class="settings" id="settingsPanel">
      <div class="setting-row">
        <label>Server URL:</label>
        <input type="text" id="serverUrl" value="wss://polaroidize-server-production.up.railway.app">
      </div>
      <div class="setting-row">
        <label>Mosaic Detail:</label>
        <select id="mosaicSize">
          <option value="20" selected>High Privacy (matches grid)</option>
          <option value="40">Medium Privacy (2x2 grid squares)</option>
          <option value="60">Low Privacy (3x3 grid squares)</option>
        </select>
      </div>
    </div>

    <div class="cta-section">
      <div class="final-step-label" id="finalStepLabel">âœ“ Ready to Go Live - Final Step</div>
      <button id="connectBtn">Connect to Photographer</button>
      <button id="startBtn" style="display: none;">Start Modeling Session</button>
      <button id="stopBtn" style="display: none;">End Session</button>
      <div class="status" id="statusText"></div>

      <div class="reassurance" id="reassurance">
        <strong>ðŸ’¡ Your Privacy is Protected</strong>
        Your camera view is only shared with the photographer. You'll see an abstract, pixelated mirror - not your actual appearance.
      </div>
    </div>

    <!-- Polaroid Gallery -->
    <div class="polaroid-gallery" id="polaroidGallery">
      <div class="polaroid-gallery-header">ðŸ“¸ Your Polaroids</div>
      <div id="polaroidContainer"></div>
    </div>
  </div>

  <canvas id="hiddenCanvas" style="display: none;"></canvas>

  <script>
    const video = document.getElementById('video');
    const mosaicCanvas = document.getElementById('mosaicCanvas');
    const mosaicCtx = mosaicCanvas.getContext('2d');
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const hiddenCtx = hiddenCanvas.getContext('2d');

    const connectBtn = document.getElementById('connectBtn');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const serverUrlInput = document.getElementById('serverUrl');
    const mosaicSizeSelect = document.getElementById('mosaicSize');
    const liveBadge = document.getElementById('liveBadge');
    const statusText = document.getElementById('statusText');
    const stepIndicator = document.getElementById('stepIndicator');
    const reassurance = document.getElementById('reassurance');
    const settingsPanel = document.getElementById('settingsPanel');
    const finalStepLabel = document.getElementById('finalStepLabel');
    const polaroidGallery = document.getElementById('polaroidGallery');
    const polaroidContainer = document.getElementById('polaroidContainer');
    const screenFlash = document.getElementById('screenFlash');
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    const toastActions = document.getElementById('toastActions');

    let ws = null;
    let toastTimeout = null;
    let stream = null;
    let mosaicAnimationId = null;
    let streamInterval = null;
    let currentStep = 1;

    function updateStep(step, message) {
      currentStep = step;
      stepIndicator.textContent = `Step ${step} of 2`;
      statusText.textContent = message || '';
    }

    // Step 1: Connect to server
    connectBtn.addEventListener('click', () => {
      settingsPanel.classList.add('visible');
      const serverUrl = serverUrlInput.value.trim();

      try {
        ws = new WebSocket(serverUrl);

        ws.onopen = () => {
          ws.send(JSON.stringify({ type: 'register', role: 'broadcaster' }));
          connectBtn.style.display = 'none';
          startBtn.style.display = 'block';
          finalStepLabel.classList.add('visible');
          reassurance.classList.add('visible');
          settingsPanel.classList.remove('visible');
          updateStep(2, 'âœ“ Connected to photographer');
        };

        ws.onerror = () => {
          statusText.textContent = 'âš  Connection failed. Check server URL.';
          statusText.className = 'status';
        };

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            if (message.type === 'polaroid') {
              // Add polaroid to gallery
              addPolaroidToGallery(message.imageUrl);
            } else if (message.type === 'shutter') {
              // Trigger flash effect when photographer takes photo
              screenFlash.classList.add('active');
              setTimeout(() => {
                screenFlash.classList.remove('active');
              }, 600);
            }
          } catch (err) {
            console.error('Error handling message:', err);
          }
        };

        ws.onclose = () => {
          location.reload();
        };
      } catch (err) {
        statusText.textContent = 'âš  Invalid server URL';
      }
    });

    // Toast notification system
    function showToast(message, actions = [], duration = 5000) {
      // Clear existing timeout
      if (toastTimeout) {
        clearTimeout(toastTimeout);
      }

      // Set message
      toastMessage.textContent = message;

      // Clear and set actions
      toastActions.innerHTML = '';
      actions.forEach(action => {
        const btn = document.createElement('button');
        btn.className = 'toast-btn' + (action.primary ? ' primary' : '');
        btn.textContent = action.text;
        btn.addEventListener('click', () => {
          action.onClick();
          hideToast();
        });
        toastActions.appendChild(btn);
      });

      // Show toast
      toast.classList.add('show');

      // Auto-hide after duration
      if (duration > 0) {
        toastTimeout = setTimeout(hideToast, duration);
      }
    }

    function hideToast() {
      toast.classList.remove('show');
      if (toastTimeout) {
        clearTimeout(toastTimeout);
        toastTimeout = null;
      }
    }

    // Add polaroid to persistent gallery
    function addPolaroidToGallery(imageUrl) {
      // Show gallery if hidden
      polaroidGallery.classList.add('visible');

      // Create polaroid item
      const polaroidItem = document.createElement('div');
      polaroidItem.className = 'polaroid-item';

      const img = document.createElement('img');
      img.src = imageUrl;
      img.alt = 'Polaroid';
      img.crossOrigin = 'anonymous';

      const actions = document.createElement('div');
      actions.className = 'polaroid-item-actions';

      const downloadBtn = document.createElement('button');
      downloadBtn.className = 'polaroid-item-btn download';
      downloadBtn.textContent = 'Download';
      downloadBtn.addEventListener('click', () => downloadPolaroidWithBorder(imageUrl));

      actions.appendChild(downloadBtn);
      polaroidItem.appendChild(img);
      polaroidItem.appendChild(actions);

      // Add to top of container
      polaroidContainer.insertBefore(polaroidItem, polaroidContainer.firstChild);

      // Show toast notification
      showToast('ðŸ“¸ New Polaroid ready!', [
        {
          text: 'View Gallery',
          primary: true,
          onClick: () => {
            polaroidGallery.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }
      ], 6000);
    }

    // Download polaroid with white border
    async function downloadPolaroidWithBorder(imageUrl) {
      try {
        // Create canvas to render polaroid with white border
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size based on i-Type dimensions (3.5" x 4.2" at 300 DPI)
        const dpi = 300;
        const width = 3.5 * dpi; // 1050px
        const height = 4.2 * dpi; // 1260px
        canvas.width = width;
        canvas.height = height;

        // Draw white paper background with subtle texture
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#fefefe');
        gradient.addColorStop(0.25, '#fcfcfc');
        gradient.addColorStop(0.5, '#fafaf8');
        gradient.addColorStop(0.75, '#fcfcfc');
        gradient.addColorStop(1, '#fefefe');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        // Calculate photo area (3.1" x 3.1" centered)
        const photoSize = 3.1 * dpi; // 930px
        const leftBorder = (width - photoSize) / 2;
        const topBorder = 0.2 * dpi; // ~60px

        // Load and draw the image
        const img = new Image();
        img.crossOrigin = 'anonymous';

        await new Promise((resolve, reject) => {
          img.onload = () => {
            ctx.drawImage(img, leftBorder, topBorder, photoSize, photoSize);
            resolve();
          };
          img.onerror = reject;
          img.src = imageUrl;
        });

        // Convert to blob
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));

        // Try to use Web Share API on mobile (allows "Save to Photos")
        const isMobile = navigator.userAgent.match(/(iPad|iPhone|iPod|Android)/i);

        if (isMobile && navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], 'polaroid.png')] })) {
          // Use native share menu (includes "Save to Photos" on iOS/Android)
          const file = new File([blob], 'polaroid-' + Date.now() + '.png', { type: 'image/png' });
          await navigator.share({
            files: [file],
            title: 'Polaroid Photo'
          });
        } else {
          // Fallback: traditional download or open in new tab
          const dataURL = canvas.toDataURL('image/png');

          if (isMobile) {
            // On mobile, open in new tab so user can long-press to save
            const win = window.open('', '_blank');
            win.document.write('<img src="' + dataURL + '" style="max-width:100%;" alt="Long press to save">');
            win.document.close();
          } else {
            // Desktop: direct download
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'polaroid-' + Date.now() + '.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
          }
        }

        // Show success toast
        showToast('âœ“ Successfully saved', [], 3000);
      } catch (err) {
        console.error('Download failed:', err);
        showToast('âœ— Save failed. Please try again.', [], 3000);
      }
    }

    // Step 2: Start modeling (request camera + start streaming)
    startBtn.addEventListener('click', async () => {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });

        video.srcObject = stream;

        video.addEventListener('loadedmetadata', () => {
          if (!mosaicAnimationId) renderMosaic();

          // Start streaming immediately
          const fps = 15;
          streamInterval = setInterval(sendFrame, 1000 / fps);

          liveBadge.classList.add('active');
          startBtn.style.display = 'none';
          stopBtn.style.display = 'block';
          finalStepLabel.classList.remove('visible');
          reassurance.classList.remove('visible');
          updateStep(2, 'âœ“ Live! Photographer can see you now');
          statusText.className = 'status success';
        }, { once: true });

        video.addEventListener('playing', () => {
          if (!mosaicAnimationId) renderMosaic();
        }, { once: true });

      } catch (err) {
        statusText.textContent = 'âš  Camera access denied';
        statusText.className = 'status';
      }
    });

    // Stop streaming
    stopBtn.addEventListener('click', () => {
      if (streamInterval) clearInterval(streamInterval);
      if (mosaicAnimationId) cancelAnimationFrame(mosaicAnimationId);
      liveBadge.classList.remove('active');
      stopBtn.style.display = 'none';
      startBtn.style.display = 'block';
      finalStepLabel.classList.add('visible');
      updateStep(2, 'Session paused');
      statusText.className = 'status';
    });

    // Mosaic rendering - maintains video aspect ratio
    function renderMosaic() {
      if (!video.paused && !video.ended && video.readyState >= 2) {
        try {
          const blockSize = parseInt(mosaicSizeSelect.value);
          const videoWidth = video.videoWidth;
          const videoHeight = video.videoHeight;

          if (videoWidth && videoHeight) {
            // Update container to match video aspect ratio
            const videoContainer = document.querySelector('.video-container');
            const aspectRatio = videoWidth / videoHeight;
            videoContainer.style.aspectRatio = aspectRatio;

            const containerWidth = mosaicCanvas.clientWidth;
            const containerHeight = mosaicCanvas.clientHeight;

            // Calculate blocks based on actual video dimensions
            const blocksWide = Math.ceil(containerWidth / blockSize);
            const blocksHigh = Math.ceil(containerHeight / blockSize);

            // Set canvas to block count (will be scaled up by CSS)
            mosaicCanvas.width = blocksWide;
            mosaicCanvas.height = blocksHigh;

            mosaicCtx.imageSmoothingEnabled = false;
            mosaicCtx.drawImage(video, 0, 0, blocksWide, blocksHigh);
          }
        } catch (err) {
          console.error('Mosaic error:', err);
        }
      }
      mosaicAnimationId = requestAnimationFrame(renderMosaic);
    }

    // Send frame to server
    function sendFrame() {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      // Check if WebSocket buffer is getting full (backpressure)
      if (ws.bufferedAmount > 512 * 1024) { // 512KB threshold
        console.log('Skipping frame - WebSocket buffer full');
        return;
      }

      // Reduce resolution for streaming to save memory/bandwidth
      const maxWidth = 640;
      const maxHeight = 480;
      let width = video.videoWidth;
      let height = video.videoHeight;

      // Scale down if needed
      if (width > maxWidth || height > maxHeight) {
        const scale = Math.min(maxWidth / width, maxHeight / height);
        width = Math.floor(width * scale);
        height = Math.floor(height * scale);
      }

      hiddenCanvas.width = width;
      hiddenCanvas.height = height;
      hiddenCtx.drawImage(video, 0, 0, width, height);

      hiddenCanvas.toBlob((blob) => {
        if (!blob) return;
        const reader = new FileReader();
        reader.onload = () => {
          const base64 = reader.result.split(',')[1];
          ws.send(JSON.stringify({
            type: 'frame',
            data: base64,
            timestamp: Date.now()
          }));
        };
        reader.readAsDataURL(blob);
      }, 'image/jpeg', 0.6); // Reduced quality from 0.7 to 0.6
    }
  </script>
</body>
</html>
